
# IOStream lib.

# 중간 결론 

## c++ 에서 stream

stream 은 정의 상으로 추상화된 가상 인터페이스(혹은 장치)라고한다. 처음 iostream을 배우는 사람에게는 매우 이해가 안가는 말이다. 
그러나 우리가 컴퓨터세계에서 흔이 말하는 '추상화'와 '가상화'을 잘 이해하고 있다면 매우 분명한 의미로 다가오게 될 것이다. 일단은 추상화는 다양성을 위한 것이고 가상화은 물리세계가아닌 컴퓨터에 존재하는 것을 의미한다고만 알아두자. 
리눅스에서 가상파일시스템에대하여 공부하였다면 stream이 이와 비슷한 역할을 하고 있다고 생각해도 좋을 것 같다. stream의 표면적인 역할은 각각의 다른 외부 디바이스: 키보드, 마우스, 모니터등을 대변하여 하나의 동일한 코드로 이들에게 입출력 명령을 사용할 수 있게 하는 것이다. 
스트림은 단하나의 객체가 아니다 다시말해 모든 외부장치에서 공유하는 것이아니다. 각 스트림객체는 각 장치에 맵핑되어야하며 각 스트림은 따로 스트림 버퍼를 같는다. 이 버퍼는 *put area* 만 가질 수도 있고 *get area* 만 가질수도 있고 둘다 갖는것도 가능하다. 

TODO: 버퍼의 위치, 스트림의 위치 알아내기 둘은 독립적인가 아니면 포함 관계인가? 버퍼 커널이 생성하며 커널 힘에 생성된다. 

## c 에서 stream

stream file. stream 은 물리적인 장치를 파일로 만들어주는 역할을 한다. 키보드는 입력 스트림을 통해 하나의 파일이 된다. 그러나 프로그램에서 실재파일을 읽는 속도와 키보드에서 파일로 입력하는 속도는 천지차이다. 따라서 버퍼를 통해 둘의 속도를 조율한다. 

외부장치를 개방`fopen()`하면 스트림파일을 만들고 파일포인터`FILE *`를 리턴한다. 
외부장치를 스트림파일에 연결하여 외부장치를 하나의 파일로 만드는 것이다. 스트림 파일은 버퍼(데이터가 저장될 곳)를 생성하고 버퍼를 관리하는 정보를 파일 구조체 변수에 저장한다. 파일 포인터는 이 파일 구조체를 가리킨다. 버퍼는 스트림파일 안에 단독적으로 존재한다. 
스트림파일은 커널(운영체제)로부터 실재 파일을 얻어온다. 이에대한 정보또한 파일 구조체안에 담긴다.

외부장치를 `fopen()`할 때 모드를 정해주면 입력스트림이 될지 출력스트림이 될지를 결정한다. 

이렇게 외부장치를 열면 데이터는 프로그램 메모리에 올라오게된다. 우리는 단지 파일포인터만 닫으면 나머지는 알아서 메모리에서 삭제된다.
장치를 연결한후 프로그램은 각종 인터페이스를 통해 파일을 접근할 수 있다. 입력스트림으로 부터는 `fgetc()`같은 함수를 통해 버퍼를 읽어올 수 있다. 

키보드입력이나 콘솔 출력함수들은 표준 입출력 스트림을 사용한다. 이는 표준화된것임으로 우리가 굳이 열고 닫을 필요없다. 이미 개방되어있는 표준 입출력 스트림의 버퍼를 참조하면 되는 것이다. 출력할 때는 이 버퍼에 출력한다. `stdin`,`stdout`,`stderr`가 표준 스트림파일에 해당된다. 이 세가지모두 `FILE *`이다. 

## stream의 의미 

그렇다면 어째서 이를 stream이라고 부르는가? 그 이유는 표면적인 역할 보다 이 추상화 가상 디바이스가 어떻게 작동하는가를 보면 알 수 있다. 
stream이라는 비유를 보면 뭔가 흘러들어와서 흘러가는 유체를 상상할 수 있는데 여기서 이 유체가 디바이스로부터 받는 데이터라고 보면 된다. 

이 데이터는 기본적으로 character sequence 이다. 이 일련의 문자열들은 일단 컴퓨터로들어오면 stream 으로 흘러가게되고 이를 associated charactor sequence( source 또는 sink ) 라고 부르게 된다. 
이때 associated character sequence는 OS API(TCP socket, file,...)를 통해 흘러들어온 데이터를 의미할 수도있다(이 때는 OS API가 일종의 외부장치가 되는 것이다). 또는 `vector`, `array`,`string 리터럴` 과 같은 컨테이너도 추상화 디바이스(stream)가 될 수 있다. 이 추상화 디바이스를 접근하여 실재로 데이터를 다루려면 우리는 stream의  서브스트림격인 *put area* 와 *get area*에 접근해야한다.

	- *put area* 출력을 기다리는 characters   
	- *get area* 읽기가 가능한 characters 

다만 이들 접근은 사용자가 직접 하지않고 `basic_streambuf`의 특수화 클래스(두가지인데 하나는 `char`형으로 특수화 된 것, 하나는 `wchar_t`이다. 두번째 특수화 템플릿의 클래스명앞에는 w가 붙는다)인 streambuf클래스의 객체가 관리한다. `basic_streambuf` 클래스는 문자 시퀸스에 입출력을 제어한다.
이 두개의 영역(`get area`, `put area`)은 controlled character sequence 라는 이름 아래 속해있다. 이것이 우리가 흔이 말하는 버퍼(buffer)이다!!ㅠㅠ buffer는 3개의 포인터를 통해 조작 되는데 그 포인터는 각각 다음과 같다. 참고로 이 buffer는 템플렛 변수 `CharT`의 배열이다. *basic_streambuf템플릿클래스의 원형 참조.*   

	- *beginning pointer* 버퍼(=*controlled charactor sequence*)에서 가장 처음(낮은) 위치의 요소를 가리킨다. 
	- *next pointer* 읽기나 쓰기를 위해서 대기하고 있는 다음 요소를 가리킨다. 
	- *end pointer* 버퍼가 끝나고 **하나 다음**을 가리킨다.

이들 포인터를 제어하는 함수에 대한 설명중 다음과 같은 말이 있다. 
"These are all protected methods, which are intended to be used by virtual function in classes derived from `streambuf`."

각 stream 은 put get 구역을 가지고 각각에 해당하는 입출력 방식(에를 들면 formmatting)이 존제한다. 
이것이 당현함은 우리가 직접 ostream 같은 입출력 객체를 만들 수 있는 것을 보면 알수 있다.  이들 각객체는 각각의 streambuf 를 가지고있다. 
cout 객체로 `streambuf`객체를 뽑아올 수도 있다. 이는 곧 어떤 디바이스로부터 그 디바이스의 입출력 형식을 그대로 가져온다는 것을 의미한다. 
위 3개의 포인터를 제어하는 것은 스트림의 읽기 출력을 맘대로 요리할 수있다는 의미이기 때문이다.  

`streambuf` 객체는 get area을 지원할수도 put area을 지원할 수도 둘다 지원할 수도있으면서 둘다 지원할 경우 6개의 포인터가 하나의 문자 배열을 가리킬 수도 두개의 문자 배열을 가리킬 수도 있다. 

controlled sequence에서 문자를 표현하고 인코딩하는 방식은 associated sequence에서와 다를 수 있다.
예를 들어, UTF-8 이나 멀티마이트 파일을 `std::wfstream`을 통해 접근하고자 할때 controlled sequence는 `wchar_t`를 사용하고 associated sequence는 바이트열을 사용하게된다. 

	- *controlled character sequence* (buffer) : 입력(input) 시퀸스(*get are*라고도 불림.) **또는/그리고** 출력(output) 시퀸스(*put area*)를 포함한다. 입출력을 버퍼링하는 역할을 한다. 즉 스트림으로 flush 되기전에 공간을 마련하여 거기에 입출력될 데이터를 잠시 쌓아둔다. 혹은 바로바로 stream 으로 내보낼 수도 있다. 
	- *associated character swquence* (source 예로 키보드 입력시에 or sink 예로 화면 출력시에) : OS API(file, TCP socket, serial port, other character device)를 통해 접근할 수 있는 개체를 의미하기도한다. 혹은 `std::vector`,`array`,`string literal`의 객체(character의 source나 sink가 될 수 있는 객체를 의미 즉, 저장할 수도 읽어올 수도있다.)를 의미할 수도 있다. 우리가 흔이 말하는 스트림은 바로 이것이다. 

이런식의 resuablility를 높인 소프트웨어 설계방식을 Low Coupling 이라한다. 

### wchar_t 

유니코드 형식의 문자를 사용하려면 `wchar_t` 를 사용하여야한다. 따라서 초기화는 다음과 같이 유니코드임을 알려줘야한다. 

	wchar_t *str = L"유니코드";

## 버퍼의 필요성(후반 결론)

 파일을 하드디스크로 부터 읽은 작업은 매우 비싼 작업인 반면에 메모리에 접근하는 것은 매우 빠른 작업이다. 이로인해 두 작업간에 큰 비용차이가 발생하게된다. 비효율적이 된다는 말이다. 무슨 말인가 하면 프로그램은 기본적으로 메모리에 올라와서 실행이 된다. 모든것은 메모리상에 존재하고 있다.
 
메모리상에 포인터를 이리 저리 움직이면서 프로그램이 실행되는 것인데 갑자기 저 먼나라 하드디스크에 있는 파일을 불러와야한다고 하면 프로그램은 이파일이 완전히 불려 올때까지는 아무일도못하고 시간을 낭비하게 된다. 더군다나 프로그래머가 이 하드디스크의 구조를 다공부하고 읽어들여햐하는 프로그램을 만드는 것은 더 힘든일이 될 것이다. 

이것을 해결하는 것이 결국은 스트림라이브러리이다. 장치가 무엇이냐에 관계없이 단지 라이브러리를 이용함으로 우리는 이제 장치에 간단한 코드만으로 접근이 가능해 졌다. 하지만 여전히 문제는 남아있다. 
하드디스크에는 접근이 가능한데 속도차이는 여전히 존재한다. 하드디스크로 부터 읽어오는 동안 기다려함으로 비효율적인 프로그램이 되어버린다. 
  
그래서 프로그래머들을 한가지 방법를 마련했는데 이것이 버퍼이다. 버퍼는 컴퓨터의 메모리의 일부이다. 이제 우리는 임시적으로 파일을 거기에 저장해두고 속도의 차이를 어느정도 줄일 수 있게되었다(여기서 파일은 스트림에 대응하여 보면 된다). 
얼마만큼의 버퍼를 필요로할지 얼마의 데이터를 버퍼링할지 아니면 버퍼링을 하지 않을지는 프로그래머의 임맛따라 정하면 된다. 

그렇다면 파일을 쓸때는? 버퍼는 스트림입장(예를 들어 하드드라이브의 파일)에서는 사실 보이지않는다. 다만 버퍼에 저장된 정보가 스트림으로 쏟아질 때`flush` 비로소 스트림으로 흘러가게 되는 것이다. 
즉, 프로그램이 파일을 쓰는 것은 임시적으로 속도가 빠른 메모리에 쓰게 되고 어느정도의 파일이 메모리에 쓰이면 `flush`하게 되는데 이때 하드디스크와 메모리가 동기화된다. 

참고적으로 표준 c++에서 `flush`가 출력에서만 정의되어 있는 까닭이 이것이다. 데이터를 보낼 때(출력)는 데이터의 구조가 어떻든지 상관없다. 단지 바이트열일 뿐이다. 그저 스트림으로 솓아넣기만하면된다. 하지만 입력스트림의 경우에는 이야기가 달라진다. 단순이 읽기만하면 안된다. 데이터의 구조를 알고 그에 해당하는 단위로 바이트를 잘라야한다. 때문에 `flush`같이 무작정 쏟아붓는 액션이 위험한 것이다. 그럼에도 불구하고 몇몇 운영체제에서는 입력에대한 `flush`도 필요에 의해 정의하고 있다.  

TODO : flush를 통해 동기화될 시에 메모리를 무조건 비우는가? 아니면 그 위에 다시쓰는가? 

### flush 
`std::ostream::flush()` 는 실제로 관련된 스트림의 버퍼로 부터 `std::streambuf::pubsync()` 를 호출한다. 스트림버퍼는 사용하는 버퍼가 오버플로우하거나 내부 표현이 외부 의 목적지와 동기되어야할 때 문자열을 버퍼링하거나 목적지로 보내줘야한다.

## put get 영역 조작 함수 











# A Gentle Introduction to C++ IO Streams 번역 

c++의 가장 큰 장점중하나는 I/O 시스템, IO Stream들 이다. Bjarne Stroustrup이 말했듯이, "일반적인 I/O 기기를 프로그래밍 언어를 위해 설계하고 구현하는 일은 악명높게 어려운이다.". 그는 훌륭한 일을 했다. 그리고 c++ IOstreams library는 c++이 성공한 이유이기도 하다. 
IO stream 은 놀라운 유연성을 제공하면서도 간단한 방법으로 입출력을 디자인할 수 있는 방법이다. 

IOstream 은 다음과 같은 기능을 제공하기 때문에 데이터 조작을 위해 다양한 방법으로 사용될 수 있다. 

	- stream 은 내부적으로 그저 문자열일 뿐이다. 

 문자열은 `char`가 될 수도 `wchar_t`가 될 수도 있다. 스트림은 어떠한 저장 매체에도 범용의 문자 기반 인터페이스를 제공한다. 그러면서도 그 저장매체에 대한 디테일한 지식을 요구하지 않는다.

	- 스트림에는 내장 데이터 타입이 쓰인다. 

사용자 정의 타입도`<<`(삽입),`>>`(추출) 연산자 오버로딩을 통해 스트림으로 쓰일 수 있다.     

	- 스르림 라이브러리의 통합된 접근방식은 매우 쓰기 쉽게 만들어 준다. 

 일관적인 인터페이스를 사용함으로서 네트웍을 통한 파일전송, 화면 출력등을 쉽게한다. 

## 입출력의 진정한 의미 

입출력이 무엇인지 알기위해서 정보를 하나의 문자열을 흐름이라고 생각해보자. 이것은 충분히 납득이가는데 왜냐하면 우리가 무엇을 키보드로 입력하든간에 오직 문자열만이 그 대상이 되기 때문이다. 사용자가 숫자 7309를 입력한다고하자 잠깐! 그런데 사용자가 어떻게 '숫자'를 입력했다고 알 수 있는데?
문제는 모른다는 것이다. 우리가 가진것은 단지 4개의 문자열일 뿐이다. 입력하는 것이 문자일지 숫자일지 혹은 /dev/random에 넣을 fodder일지는 전적으로 프로그래머에게 달려있다. 


## 스트림의 동작 원리 

 스트림은 시리얼 인터페이스이다.  

스트림의 "시리얼"이라는 특징은 그 인터페이스에서 매우 중요한 요소이다.

가장 낮은 래벨에서 저장매체와 가까이 있는 것은 버퍼(스트림 버퍼, streambuf)이다. 
버퍼의 가장 기본적인 기능은 다음과 같다.   

1. 먼저 스트림은 적절한 타입과 적정한 모드로 초기화된다. 
2. 그다음에는 어디서 I/O가 발생하는지 구체화할 수 있다. get과 put 포인터를 이용한다. 어떤식으로 스트림을 여는가에 따라 위치는 이미 정해저있을 지모른다. 예를 들어 ios::app를 이용해 스트림을 열면 자동적으로 get 포인터는 스트림의 마지막을 열게된다. 



